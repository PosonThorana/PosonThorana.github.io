<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>nqame Project - Fixed Layout</title>
    <!-- Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font for a modern look */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        /* Import Noto Sans Sinhala Black from Google Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+Sinhala+Black&display=swap');

        body {
            /* Prioritize Noto Sans Sinhala Black, fallback to Inter and sans-serif */
            font-family: 'Noto Sans Sinhala Black', 'Inter', sans-serif;
        }

        /* Base styling for outer circle bulbs */
        .outline-bulb {
            position: absolute; /* Position bulbs absolutely within their parent circle */
            width: 7px; /* Reduced from 8px to 7px */
            height: 7px; /* Reduced from 8px to 7px */
            border-radius: 9999px; /* Make it perfectly circular */
            background-color: #4a5568; /* Initial dark gray color */
            transition: background-color 0.3s ease-in-out; /* Smooth transition for color changes */
            /* Center the bulb itself at the calculated position */
            transform: translate(-50%, -50%);
        }

        /* Styling for inner halo bulbs (smaller) */
        .inner-halo-bulb {
            position: absolute; /* Position bulbs absolutely within their parent container */
            width: 5px; /* Reduced from 6px to 5px */
            height: 5px; /* Reduced from 5px to 5px */
            border-radius: 9999px; /* Make it perfectly circular */
            background-color: #4a5568; /* Initial dark gray color */
            transition: background-color 0.3s ease-in-out; /* Smooth transition for color changes */
            /* Center the bulb itself at the calculated position */
            transform: translate(-50%, -50%);
        }

        /* Styles for the overlay (dark background when zoom window is active) */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent black */
            z-index: 90; /* Below the zoomed window, but above main content */
            opacity: 0;
            pointer-events: none; /* Allows clicks to pass through when not active */
            transition: opacity 0.3s ease-in-out;
        }

        .overlay.active {
            opacity: 1;
            pointer-events: auto; /* Captures clicks when active */
        }

        /* Styles for the full screen zoom window */
        #full-screen-zoom-window {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8); /* Start slightly smaller and centered */
            opacity: 0;
            pointer-events: none; /* Initially not interactive */
            z-index: 100; /* On top of everything */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: black;
            border-radius: 0.5rem; /* rounded-lg */
            padding: 10px; /* Padding for the entire window */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-xl */
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            width: 280px; /* Increased width for the entire window */
            height: 400px; /* Increased height for the entire window */
            border: 2px solid #fbbf24; /* yellow-500 border for the main window */
        }

        #full-screen-zoom-window.active {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1); /* Zoom to original size */
            pointer-events: auto; /* Make interactive */
        }

        /* Container for bulbs within the zoom window. Must be relative to #full-screen-zoom-window */
        #zoom-window-bulbs-container {
            position: absolute;
            inset: 0; /* Cover the entire parent */
            z-index: 1; /* Below the image display area and title bar */
        }

        /* Styles for the image display area inside the zoom window */
        #image-display-area {
            position: relative; /* To contain bulbs if needed, but not for this design */
            width: 220px; /* Increased width for the square image area */
            height: 220px; /* Increased height for the square image area */
            background-color: black;
            border: 2px solid #fbbf24; /* Yellow border for the image area */
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden; /* Hide any overflow from image */
            border-radius: 0.5rem; /* rounded-lg */
            z-index: 2; /* Ensure it's above the bulbs */
        }

        #zoomed-display-image {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Ensure image fits while maintaining aspect ratio */
        }

        /* Styles for the title bar inside the zoom window */
        #zoomed-image-title-bar {
            width: 100%; /* Match width of image display area */
            height: 50px; /* Fixed height for title bar */
            background-color: #fbbf24; /* yellow-500 */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem; /* text-2xl */
            font-weight: bold; /* font-bold */
            color: black; /* text-black */
            border-radius: 0.5rem; /* rounded-lg */
            margin-top: 20px; /* Increased space between image area and title bar */
            z-index: 2; /* Ensure it's above the bulbs */
        }
    </style>
</head>
<!-- The body uses flexbox to center the main design container -->
<body class="bg-black flex items-center justify-center min-h-screen p-4 overflow-hidden">

    <!-- Overlay for click-away functionality -->
    <div id="overlay" class="overlay"></div>

    <!-- Main design container -->
    <!-- This div acts as the canvas for the entire design.
         It's set to 'relative' so its children can be absolutely positioned within it.
         Fixed width and height for a non-responsive layout. -->
    <div class="relative w-[300px] h-[533px] bg-black rounded-lg shadow-2xl">
        <!-- Central Rectangle (Buddha Image Slot) - Original Layout -->
        <div id="buddha-image-container" class="absolute left-[50%] -translate-x-1/2 top-[95px] w-[105px] h-[373px] bg-black rounded-[2.5rem] flex items-center justify-center shadow-xl z-50 border-2 border-yellow-500">
            <!-- Inner container for the Buddha image slot bulbs. No inset to control positioning via JS offset. -->
            <div id="inner-halo-container" class="absolute inset-0 z-52"></div>
            <!-- Original Buddha Image -->
            <img src="./budhdha.png" alt="Buddha Image" class="absolute w-full h-[105%] object-cover rounded-[2.5rem] z-55 -top-[1%] transform rotate-1">
        </div>

        <!-- Circles -->
        <!-- Fixed positioning and size. Circles now have a yellow border. -->
        <!-- Order of circles adjusted for desired z-index layering (later in HTML means on top for same z-index) -->

        <!-- Left Bottom Circle -->
        <div id="circle-4" class="absolute top-[330px] left-[-30px] w-[135px] h-[135px] rounded-full shadow-lg z-10 border-2 border-yellow-500 cursor-pointer">
            <!-- Image placeholder for circle 4 -->
            <img src="./Gemini_Generated_Image_pz9b4cpz9b4cpz9b.png" alt="Circle Image 4" class="w-full h-full object-cover rounded-full">
            <!-- Bulbs will be dynamically added here by JavaScript -->
        </div>
        <!-- Left Middle Circle -->
        <div id="circle-3" class="absolute top-[200px] left-[-30px] w-[135px] h-[135px] rounded-full shadow-lg z-10 border-2 border-yellow-500 cursor-pointer">
            <!-- Image placeholder for circle 3 -->
            <img src="./ChatGPT Image Jun 10, 2025, 08_53_43 AM.png" alt="Circle Image 3" class="w-full h-full object-cover rounded-full">
            <!-- Bulbs will be dynamically added here by JavaScript -->
        </div>
        <!-- Left Top Circle -->
        <div id="circle-2" class="absolute top-[70px] left-[-30px] w-[135px] h-[135px] rounded-full shadow-lg z-10 border-2 border-yellow-500 cursor-pointer">
            <!-- Image placeholder for circle 2 -->
            <img src="./ChatGPT Image Jun 10, 2025, 09_01_28 AM.png" alt="Circle Image 2" class="w-full h-full object-cover rounded-full">
            <!-- Bulbs will be dynamically added here by JavaScript -->
        </div>

        <!-- Right Bottom Circle -->
        <div id="circle-7" class="absolute top-[330px] right-[-30px] w-[135px] h-[135px] rounded-full shadow-lg z-10 border-2 border-yellow-500 cursor-pointer">
            <!-- Image placeholder for circle 7 -->
            <img src="./generate very same i.png" alt="Circle Image 7" class="w-full h-full object-cover rounded-full">
            <!-- Bulbs will be dynamically added here by JavaScript -->
        </div>
        <!-- Right Middle Circle -->
        <div id="circle-6" class="absolute top-[200px] right-[-30px] w-[135px] h-[135px] rounded-full shadow-lg z-10 border-2 border-yellow-500 cursor-pointer">
            <!-- Image placeholder for circle 6 -->
            <img src="./ChatGPT Image Jun 10, 2025, 09_53_58 AM.png" alt="Circle Image 6" class="w-full h-full object-cover rounded-full">
            <!-- Bulbs will be dynamically added here by JavaScript -->
        </div>
        <!-- Right Top Circle -->
        <div id="circle-5" class="absolute top-[70px] right-[-30px] w-[135px] h-[135px] rounded-full shadow-lg z-10 border-2 border-yellow-500 cursor-pointer">
            <!-- Image placeholder for circle 5 -->
            <img src="./ChatGPT Image Jun 10, 2025, 09_41_25 AM.png" alt="Circle Image 5" class="w-full h-full object-cover rounded-full">
            <!-- Bulbs will be dynamically added here by JavaScript -->
        </div>

        <!-- Top Center Circle (positioned last to overlap side circles) -->
        <div id="circle-1" class="absolute top-[1px] left-[50%] -translate-x-1/2 w-[145px] h-[145px] rounded-full shadow-lg z-10 border-2 border-yellow-500 cursor-pointer">
            <!-- Image placeholder for circle 1 -->
            <img src="./ChatGPT Image Jun 10, 2025, 09_08_58 AM.png" alt="Circle Image 1" class="w-full h-full object-cover rounded-full">
            <!-- Bulbs will be dynamically added here by JavaScript -->
        </div>

        <!-- Bottom Title Rectangle (now a plain rectangle) -->
        <!-- Fixed height and placed behind circles with z-0 -->
        <div class="absolute bottom-[-10px] left-0 w-full h-[106px] bg-yellow-500 flex items-center justify-center p-4 shadow-xl rounded-lg z-0 pt-4">
            <h1 class="text-black text-3xl sm:text-4xl md:text-5xl font-bold text-center">
                සත් සතිය
            </h1>
        </div>
    </div>

    <!-- NEW: Full Screen Zoom Window -->
    <div id="full-screen-zoom-window">
        <!-- New container for bulbs along the border of the zoom window -->
        <div id="zoom-window-bulbs-container" class="absolute inset-0"></div>

        <!-- Image display area inside the zoom window -->
        <div id="image-display-area">
            <img id="zoomed-display-image" src="" alt="Zoomed Image">
        </div>
        <!-- Title bar for the zoomed image -->
        <div id="zoomed-image-title-bar">
            <h2 id="zoomed-image-title" class="text-2xl font-bold text-center">Image Title</h2>
        </div>
    </div>

    <script>
        // DOM Elements for the main design
        const buddhaImageContainer = document.getElementById('buddha-image-container'); // Original Buddha image container
        const innerHaloContainer = document.getElementById('inner-halo-container'); // Bulbs for Buddha image container
        const overlay = document.getElementById('overlay');

        // DOM Elements for the new zoom window
        const fullScreenZoomWindow = document.getElementById('full-screen-zoom-window');
        const zoomWindowBulbsContainer = document.getElementById('zoom-window-bulbs-container'); // New bulb container for zoom window
        const imageDisplayArea = document.getElementById('image-display-area'); // Area within zoom window for image
        const zoomedDisplayImage = document.getElementById('zoomed-display-image'); // Image element inside zoom window
        const zoomedImageTitle = document.getElementById('zoomed-image-title'); // Title element inside zoom window

        // Original Buddha image source and classes (for resetting)
        const originalBuddhaImageSrc = './budhdha.png';
        const originalBuddhaImageClasses = 'absolute w-full h-[105%] object-cover rounded-[2.5rem] z-55 -top-[1%] transform rotate-1';

        // Array of colors for the outer bulbs
        const outerBulbColors = [
            '#FFD700', // Gold
            '#FFA500', // Orange
            '#FF4500', // OrangeRed
            '#FFFF00', // Yellow
            '#ADFF2F', // GreenYellow
            '#00CED1', // DarkTurquoise
            '#1E90FF', // DodgerBlue
            '#FF69B4', // HotPink
            '#8A2BE2', // BlueViolet
            '#FFFFFF'  // White
        ];

        // Array of colors for the inner halo bulbs (mostly whites and subtle yellows)
        const innerBulbColors = [
            '#FFFFFF', // White
            '#F0F0F0', // Light Gray
            '#E0E0E0', // Lighter Gray
            '#FFFFE0', // Light Yellow
            '#FFFACD'  // Lemon Chiffon
        ];


        /**
         * Creates and appends bulbs along the outline of a given container.
         * @param {HTMLElement} containerElement - The container element to add bulbs to.
         * @param {number} numberOfBulbs - The total number of bulbs to create.
         * @param {string} bulbClassName - The CSS class name to apply to each bulb (e.g., 'outline-bulb', 'inner-halo-bulb').
         * @param {number} offsetFromContainerEdge - Pixels inwards from the container's edge where bulbs are placed.
         * This offset is from the *border-box* edge of the container.
         */
        function createOutlineBulbs(containerElement, numberOfBulbs, bulbClassName, offsetFromContainerEdge) {
            const style = window.getComputedStyle(containerElement);
            const containerWidth = parseFloat(style.width);
            const containerHeight = parseFloat(style.height);

            // Determine if the container is circular or rectangular based on its rounded-ness/dimensions
            const isCircular = containerElement.classList.contains('rounded-full');

            // Calculate the effective dimensions for positioning bulbs based on offset
            const effectiveWidth = containerWidth - (2 * offsetFromContainerEdge);
            const effectiveHeight = containerHeight - (2 * offsetFromContainerEdge);

            // Only clear existing bulbs of the specified class, preserving other content like images.
            const existingBulbs = containerElement.querySelectorAll(`.${bulbClassName}`);
            existingBulbs.forEach(bulb => bulb.remove());

            for (let i = 0; i < numberOfBulbs; i++) {
                const bulb = document.createElement('div');
                bulb.classList.add(bulbClassName);

                let x, y;

                if (isCircular) {
                    // Existing circular logic for outer circles
                    const angle = (i / numberOfBulbs) * 2 * Math.PI;
                    const effectiveRadius = effectiveWidth / 2;
                    x = (containerWidth / 2) + effectiveRadius * Math.cos(angle - Math.PI / 2);
                    y = (containerHeight / 2) + effectiveRadius * Math.sin(angle - Math.PI / 2);
                } else {
                    // Logic for non-circular (rectangular with rounded corners)
                    const perimeter = 2 * (effectiveWidth + effectiveHeight);
                    const segmentLength = perimeter / numberOfBulbs;
                    let currentLength = i * segmentLength;

                    // Calculate position along the rectangle's perimeter
                    if (currentLength < effectiveWidth) { // Top edge
                        x = offsetFromContainerEdge + currentLength;
                        y = offsetFromContainerEdge;
                    } else if (currentLength < effectiveWidth + effectiveHeight) { // Right edge
                        x = offsetFromContainerEdge + effectiveWidth;
                        y = offsetFromContainerEdge + (currentLength - effectiveWidth);
                    } else if (currentLength < 2 * effectiveWidth + effectiveHeight) { // Bottom edge
                        x = offsetFromContainerEdge + effectiveWidth - (currentLength - (effectiveWidth + effectiveHeight));
                        y = offsetFromContainerEdge + effectiveHeight;
                    } else { // Left edge
                        x = offsetFromContainerEdge;
                        y = offsetFromContainerEdge + effectiveHeight - (currentLength - (2 * effectiveWidth + effectiveHeight));
                    }
                }
                
                bulb.style.left = `${(x / containerWidth) * 100}%`;
                bulb.style.top = `${(y / containerHeight) * 100}%`;
                containerElement.appendChild(bulb);
            }
        }

        // Function to animate outline bulbs based on their class
        function animateBulbs() {
            let patternTypeOuter; // Declare at function scope
            let innerPatternTypeForHalo; // Declare at function scope

            // Animate outer circles' bulbs (main design)
            const allOuterCircleContainers = document.querySelectorAll('[id^="circle-"]');
            allOuterCircleContainers.forEach(container => {
                const bulbs = container.querySelectorAll('.outline-bulb');
                if (bulbs.length === 0) return;

                patternTypeOuter = Math.floor(Math.random() * 3); // Re-assign for each container

                if (patternTypeOuter === 0) {
                    bulbs.forEach(bulb => {
                        const randomColor = outerBulbColors[Math.floor(Math.random() * outerBulbColors.length)];
                        bulb.style.backgroundColor = randomColor;
                    });
                } else if (patternTypeOuter === 1) {
                    let delay = 0;
                    bulbs.forEach((bulb, index) => {
                        setTimeout(() => {
                            bulb.style.backgroundColor = outerBulbColors[index % outerBulbColors.length];
                        }, delay);
                        delay += 50;
                    });
                } else if (patternTypeOuter === 2) {
                    const startBulbIndex = Math.floor(Math.random() * bulbs.length);
                    let delay = 0;
                    bulbs.forEach((bulb, index) => {
                        const distance = Math.min(
                            Math.abs(index - startBulbIndex),
                            bulbs.length - Math.abs(index - startBulbIndex)
                        );
                        setTimeout(() => {
                            bulb.style.backgroundColor = outerBulbColors[distance % outerBulbColors.length];
                        }, delay + distance * 70);
                    });
                }
            });

            // Animate inner halo bulbs (main rectangle's outer bulbs)
            if (innerHaloContainer) {
                const innerBulbs = innerHaloContainer.querySelectorAll('.inner-halo-bulb');
                if (innerBulbs.length === 0) return;

                // For inner bulbs, let's always use a sequential or a simple random blink
                innerPatternTypeForHalo = Math.floor(Math.random() * 2); // Re-assign here

                if (innerPatternTypeForHalo === 0) {
                    innerBulbs.forEach(bulb => {
                        const randomColor = innerBulbColors[Math.floor(Math.random() * innerBulbColors.length)];
                        bulb.style.backgroundColor = randomColor;
                    });
                } else if (innerPatternTypeForHalo === 1) {
                    let delay = 0;
                    innerBulbs.forEach((bulb, index) => {
                        setTimeout(() => {
                            bulb.style.backgroundColor = innerBulbColors[index % innerBulbColors.length];
                        }, delay);
                        delay += 30; // Faster sequential effect for inner bulbs
                    });
                }
            }

            // Animate bulbs for the new zoom window's outer border
            if (fullScreenZoomWindow.classList.contains('active') && zoomWindowBulbsContainer) {
                const zoomWindowBulbs = zoomWindowBulbsContainer.querySelectorAll('.outline-bulb');
                if (zoomWindowBulbs.length === 0) {
                     // Ensure bulbs are created if they don't exist yet
                    createOutlineBulbs(zoomWindowBulbsContainer, 40, 'outline-bulb', 5); // 40 bulbs, 5px offset
                }
                const zoomPatternType = Math.floor(Math.random() * 3); // 0: random, 1: sequential, 2: ripple

                if (zoomPatternType === 0) {
                    zoomWindowBulbs.forEach(bulb => {
                        const randomColor = outerBulbColors[Math.floor(Math.random() * outerBulbColors.length)];
                        bulb.style.backgroundColor = randomColor;
                    });
                } else if (zoomPatternType === 1) {
                    let delay = 0;
                    zoomWindowBulbs.forEach((bulb, index) => {
                        setTimeout(() => {
                            bulb.style.backgroundColor = outerBulbColors[index % outerBulbColors.length];
                        }, delay);
                        delay += 40; // Slightly faster sequential for zoom window
                    });
                } else if (zoomPatternType === 2) {
                    const startBulbIndex = Math.floor(Math.random() * zoomWindowBulbs.length);
                    let delay = 0;
                    zoomWindowBulbs.forEach((bulb, index) => {
                        const distance = Math.min(
                            Math.abs(index - startBulbIndex),
                            zoomWindowBulbs.length - Math.abs(index - startBulbIndex)
                        );
                        setTimeout(() => {
                            bulb.style.backgroundColor = outerBulbColors[distance % outerBulbColors.length];
                        }, delay + distance * 50); // Slightly faster ripple for zoom window
                    });
                }
            }
        }

        /**
         * Zooms an image into the new full-screen zoom window.
         * @param {string} imageUrl - The URL of the image to zoom.
         * @param {string} imageAlt - The alt text of the image to use as title.
         */
        function zoomImage(imageUrl, imageAlt) {
            zoomedDisplayImage.src = imageUrl;
            zoomedDisplayImage.alt = imageAlt;
            zoomedImageTitle.textContent = imageAlt.replace('Circle Image ', 'Image '); // Set a more readable title

            // Activate overlay and show zoom window with animation
            overlay.classList.add('active');
            fullScreenZoomWindow.classList.add('active');

            // Initialize bulbs for the zoom window's outer border
            createOutlineBulbs(zoomWindowBulbsContainer, 40, 'outline-bulb', 5); // 40 bulbs, 5px offset
            animateBulbs(); // Run animation immediately for the new window
        }

        /**
         * Resets the full-screen zoom window and overlay.
         */
        function resetZoom() {
            // Deactivate overlay and hide zoom window with animation
            overlay.classList.remove('active');
            fullScreenZoomWindow.classList.remove('active');
        }

        // Initialize all bulbs for the main design when the DOM is loaded
        function initializeAllMainDesignBulbs() {
            const circleIds = ['circle-1', 'circle-2', 'circle-3', 'circle-4', 'circle-5', 'circle-6', 'circle-7'];
            const numberOfOuterBulbsPerCircle = 30; // Number of bulbs around the circumference for outer circles
            const outerBulbOffset = 5; // Pixels inwards from the border for outer bulbs (border is 2px)

            circleIds.forEach(id => {
                const circleElement = document.getElementById(id);
                if (circleElement) {
                    // Create bulbs for outer circles
                    createOutlineBulbs(circleElement, numberOfOuterBulbsPerCircle, 'outline-bulb', outerBulbOffset);
                }
            });

            // Initialize bulbs for the inner halo container (main rectangle's outer bulbs)
            if (innerHaloContainer) {
                const numberOfInnerBulbs = 20; // Fewer, denser bulbs for inner halo
                const innerBulbOffset = 5; // Increased offset to create more space
                createOutlineBulbs(innerHaloContainer, numberOfInnerBulbs, 'inner-halo-bulb', innerBulbOffset);
            }
        }

        // Event Listeners
        document.addEventListener('DOMContentLoaded', () => {
            initializeAllMainDesignBulbs(); // Initialize bulbs for the main design

            // Start the animation loop for all bulbs
            setInterval(animateBulbs, 1500); // Change pattern every 1.5 seconds

            // Add click listeners to all circle images
            const circleDivs = document.querySelectorAll('[id^="circle-"]'); // Select the div, not just the img
            circleDivs.forEach(circleDiv => {
                const img = circleDiv.querySelector('img'); // Get the img inside the div
                if (img) {
                    img.addEventListener('click', (event) => {
                        event.stopPropagation(); // Prevent background click immediately
                        zoomImage(img.src, img.alt); // Pass image src and alt
                    });
                }
            });

            // Add click listener to the overlay to reset zoom
            overlay.addEventListener('click', () => {
                resetZoom();
            });

            // Prevent clicks inside the zoom window from closing it
            fullScreenZoomWindow.addEventListener('click', (event) => {
                event.stopPropagation();
            });
        });
    </script>

</body>
</html>
