<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>nqame Project - Fixed Layout</title>
    <!-- Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font for a modern look */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }

        /* The wavy-bottom class is removed as the rectangle is now plain */

        /* Base styling for outer circle bulbs */
        .outline-bulb {
            position: absolute; /* Position bulbs absolutely within their parent circle */
            width: 7px; /* Reduced from 8px to 7px */
            height: 7px; /* Reduced from 8px to 7px */
            border-radius: 9999px; /* Make it perfectly circular */
            background-color: #4a5568; /* Initial dark gray color */
            transition: background-color 0.3s ease-in-out; /* Smooth transition for color changes */
            /* Center the bulb itself at the calculated position */
            transform: translate(-50%, -50%);
        }

        /* Styling for inner halo bulbs (smaller) */
        .inner-halo-bulb {
            position: absolute; /* Position bulbs absolutely within their parent container */
            width: 5px; /* Reduced from 6px to 5px */
            height: 5px; /* Reduced from 5px to 5px */
            border-radius: 9999px; /* Make it perfectly circular */
            background-color: #4a5568; /* Initial dark gray color */
            transition: background-color 0.3s ease-in-out; /* Smooth transition for color changes */
            /* Center the bulb itself at the calculated position */
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<!-- The body uses flexbox to center the main design container -->
<body class="bg-black flex items-center justify-center min-h-screen p-4 overflow-hidden">

    <!-- Main design container -->
    <!-- This div acts as the canvas for the entire design.
         It's set to 'relative' so its children can be absolutely positioned within it.
         Fixed width and height for a non-responsive layout. -->
    <div class="relative w-[300px] h-[533px] bg-black rounded-lg shadow-2xl">
        <!-- Central Rectangle (Buddha Image Slot) -->
        <!-- Background changed to black. Roundness adjusted. Removed overflow-hidden. -->
        <div class="absolute left-[50%] -translate-x-1/2 top-[95px] w-[105px] h-[373px] bg-black rounded-[2.5rem] flex items-center justify-center shadow-xl z-50 border-2 border-yellow-500">
            <!-- Inner container for the Buddha image slot bulbs. No inset to control positioning via JS offset. -->
            <div id="inner-halo-container" class="absolute inset-0 z-52"></div>
            <!-- Buddha Image -->
            <!-- Image src updated to direct path, top adjusted, and rotation adjusted -->
            <img src="./budhdha.png" alt="Buddha Image" class="absolute w-full h-[105%] object-cover rounded-[2.5rem] z-55 -top-[1%] transform rotate-1">
        </div>

        <!-- Circles -->
        <!-- Fixed positioning and size. Circles now have a yellow border. -->
        <!-- Order of circles adjusted for desired z-index layering (later in HTML means on top for same z-index) -->

        <!-- Left Bottom Circle -->
        <div id="circle-4" class="absolute top-[330px] left-[-30px] w-[135px] h-[135px] rounded-full shadow-lg z-10 border-2 border-yellow-500">
            <!-- Image placeholder for circle 4 -->
            <img src="./Gemini_Generated_Image_pz9b4cpz9b4cpz9b.png" alt="Circle Image 4" class="w-full h-full object-cover rounded-full">
            <!-- Bulbs will be dynamically added here by JavaScript -->
        </div>
        <!-- Left Middle Circle -->
        <div id="circle-3" class="absolute top-[200px] left-[-30px] w-[135px] h-[135px] rounded-full shadow-lg z-10 border-2 border-yellow-500">
            <!-- Image placeholder for circle 3 -->
            <img src="./ChatGPT Image Jun 10, 2025, 08_53_43 AM.png" alt="Circle Image 3" class="w-full h-full object-cover rounded-full">
            <!-- Bulbs will be dynamically added here by JavaScript -->
        </div>
        <!-- Left Top Circle -->
        <div id="circle-2" class="absolute top-[70px] left-[-30px] w-[135px] h-[135px] rounded-full shadow-lg z-10 border-2 border-yellow-500">
            <!-- Image placeholder for circle 2 -->
            <img src="./ChatGPT Image Jun 10, 2025, 09_01_28 AM.png" alt="Circle Image 2" class="w-full h-full object-cover rounded-full">
            <!-- Bulbs will be dynamically added here by JavaScript -->
        </div>

        <!-- Right Bottom Circle -->
        <div id="circle-7" class="absolute top-[330px] right-[-30px] w-[135px] h-[135px] rounded-full shadow-lg z-10 border-2 border-yellow-500">
            <!-- Image placeholder for circle 7 -->
            <img src="./generate very same i.png" alt="Circle Image 7" class="w-full h-full object-cover rounded-full">
            <!-- Bulbs will be dynamically added here by JavaScript -->
        </div>
        <!-- Right Middle Circle -->
        <div id="circle-6" class="absolute top-[200px] right-[-30px] w-[135px] h-[135px] rounded-full shadow-lg z-10 border-2 border-yellow-500">
            <!-- Image placeholder for circle 6 -->
            <img src="./ChatGPT Image Jun 10, 2025, 09_53_58 AM.png" alt="Circle Image 6" class="w-full h-full object-cover rounded-full">
            <!-- Bulbs will be dynamically added here by JavaScript -->
        </div>
        <!-- Right Top Circle -->
        <div id="circle-5" class="absolute top-[70px] right-[-30px] w-[135px] h-[135px] rounded-full shadow-lg z-10 border-2 border-yellow-500">
            <!-- Image placeholder for circle 5 -->
            <img src="./ChatGPT Image Jun 10, 2025, 09_41_25 AM.png" alt="Circle Image 5" class="w-full h-full object-cover rounded-full">
            <!-- Bulbs will be dynamically added here by JavaScript -->
        </div>

        <!-- Top Center Circle (positioned last to overlap side circles) -->
        <div id="circle-1" class="absolute top-[1px] left-[50%] -translate-x-1/2 w-[145px] h-[145px] rounded-full shadow-lg z-10 border-2 border-yellow-500">
            <!-- Image placeholder for circle 1 -->
            <img src="./ChatGPT Image Jun 10, 2025, 09_08_58 AM.png" alt="Circle Image 1" class="w-full h-full object-cover rounded-full">
            <!-- Bulbs will be dynamically added here by JavaScript -->
        </div>

        <!-- Bottom Title Rectangle (now a plain rectangle) -->
        <!-- Fixed height and placed behind circles with z-0 -->
        <div class="absolute bottom-[-10px] left-0 w-full h-[106px] bg-yellow-500 flex items-center justify-center p-4 shadow-xl rounded-lg z-0">
            <h1 class="text-black text-xl sm:text-2xl md:text-3xl font-bold text-center">
                nqame Project Title
            </h1>
        </div>
    </div>

    <script>
        // Array of colors for the outer bulbs
        const outerBulbColors = [
            '#FFD700', // Gold
            '#FFA500', // Orange
            '#FF4500', // OrangeRed
            '#FFFF00', // Yellow
            '#ADFF2F', // GreenYellow
            '#00CED1', // DarkTurquoise
            '#1E90FF', // DodgerBlue
            '#FF69B4', // HotPink
            '#8A2BE2', // BlueViolet
            '#FFFFFF'  // White
        ];

        // Array of colors for the inner halo bulbs (mostly whites and subtle yellows)
        const innerBulbColors = [
            '#FFFFFF', // White
            '#F0F0F0', // Light Gray
            '#E0E0E0', // Lighter Gray
            '#FFFFE0', // Light Yellow
            '#FFFACD'  // Lemon Chiffon
        ];


        /**
         * Creates and appends bulbs along the outline of a given container.
         * @param {HTMLElement} containerElement - The container element to add bulbs to.
         * @param {number} numberOfBulbs - The total number of bulbs to create.
         * @param {string} bulbClassName - The CSS class name to apply to each bulb (e.g., 'outline-bulb', 'inner-halo-bulb').
         * @param {number} offsetFromContainerEdge - Pixels inwards from the container's edge where bulbs are placed.
         * This offset is from the *border-box* edge of the container.
         */
        function createOutlineBulbs(containerElement, numberOfBulbs, bulbClassName, offsetFromContainerEdge) {
            const style = window.getComputedStyle(containerElement);
            const containerWidth = parseFloat(style.width);
            const containerHeight = parseFloat(style.height);

            // Determine if the container is circular or rectangular based on its rounded-ness/dimensions
            const isCircular = containerElement.classList.contains('rounded-full');

            // Calculate the effective dimensions for positioning bulbs based on offset
            const effectiveWidth = containerWidth - (2 * offsetFromContainerEdge);
            const effectiveHeight = containerHeight - (2 * offsetFromContainerEdge);

            // Corrected: Only clear existing bulbs of the specified class, preserving other content like images.
            const existingBulbs = containerElement.querySelectorAll(`.${bulbClassName}`);
            existingBulbs.forEach(bulb => bulb.remove());

            for (let i = 0; i < numberOfBulbs; i++) {
                const bulb = document.createElement('div');
                bulb.classList.add(bulbClassName);

                let x, y;

                if (isCircular) {
                    // Existing circular logic for outer circles
                    const angle = (i / numberOfBulbs) * 2 * Math.PI;
                    const effectiveRadius = effectiveWidth / 2;
                    x = (containerWidth / 2) + effectiveRadius * Math.cos(angle - Math.PI / 2);
                    y = (containerHeight / 2) + effectiveRadius * Math.sin(angle - Math.PI / 2);
                } else {
                    // Logic for non-circular (rectangular with rounded corners)
                    const perimeter = 2 * (effectiveWidth + effectiveHeight);
                    const segmentLength = perimeter / numberOfBulbs;
                    let currentLength = i * segmentLength;

                    // Calculate position along the rectangle's perimeter
                    if (currentLength < effectiveWidth) { // Top edge
                        x = offsetFromContainerEdge + currentLength;
                        y = offsetFromContainerEdge;
                    } else if (currentLength < effectiveWidth + effectiveHeight) { // Right edge
                        x = offsetFromContainerEdge + effectiveWidth;
                        y = offsetFromContainerEdge + (currentLength - effectiveWidth);
                    } else if (currentLength < 2 * effectiveWidth + effectiveHeight) { // Bottom edge
                        x = offsetFromContainerEdge + effectiveWidth - (currentLength - (effectiveWidth + effectiveHeight));
                        y = offsetFromContainerEdge + effectiveHeight;
                    } else { // Left edge
                        x = offsetFromContainerEdge;
                        y = offsetFromContainerEdge + effectiveHeight - (currentLength - (2 * effectiveWidth + effectiveHeight));
                    }
                }
                
                bulb.style.left = `${(x / containerWidth) * 100}%`;
                bulb.style.top = `${(y / containerHeight) * 100}%`;
                containerElement.appendChild(bulb);
            }
        }

        // Function to animate outline bulbs based on their class
        function animateBulbs() {
            // Animate outer circles' bulbs
            const allOuterCircleContainers = document.querySelectorAll('[id^="circle-"]');
            allOuterCircleContainers.forEach(container => {
                const bulbs = container.querySelectorAll('.outline-bulb');
                if (bulbs.length === 0) return;

                const patternType = Math.floor(Math.random() * 3); // 0: random, 1: sequential, 2: ripple

                if (patternType === 0) {
                    bulbs.forEach(bulb => {
                        const randomColor = outerBulbColors[Math.floor(Math.random() * outerBulbColors.length)];
                        bulb.style.backgroundColor = randomColor;
                    });
                } else if (patternType === 1) {
                    let delay = 0;
                    bulbs.forEach((bulb, index) => {
                        setTimeout(() => {
                            bulb.style.backgroundColor = outerBulbColors[index % outerBulbColors.length];
                        }, delay);
                        delay += 50;
                    });
                } else if (patternType === 2) {
                    const startBulbIndex = Math.floor(Math.random() * bulbs.length);
                    let delay = 0;
                    bulbs.forEach((bulb, index) => {
                        const distance = Math.min(
                            Math.abs(index - startBulbIndex),
                            bulbs.length - Math.abs(index - startBulbIndex)
                        );
                        setTimeout(() => {
                            bulb.style.backgroundColor = outerBulbColors[distance % outerBulbColors.length];
                        }, delay + distance * 70);
                    });
                }
            });

            // Animate inner halo bulbs (different pattern/colors)
            const innerHaloContainer = document.getElementById('inner-halo-container');
            if (innerHaloContainer) {
                const innerBulbs = innerHaloContainer.querySelectorAll('.inner-halo-bulb');
                if (innerBulbs.length === 0) return;

                // For inner bulbs, let's always use a sequential or a simple random blink
                const innerPatternType = Math.floor(Math.random() * 2); // 0: random, 1: sequential

                if (innerPatternType === 0) {
                    innerBulbs.forEach(bulb => {
                        const randomColor = innerBulbColors[Math.floor(Math.random() * innerBulbColors.length)];
                        bulb.style.backgroundColor = randomColor;
                    });
                } else if (innerPatternType === 1) {
                    let delay = 0;
                    innerBulbs.forEach((bulb, index) => {
                        setTimeout(() => {
                            bulb.style.backgroundColor = innerBulbColors[index % innerBulbColors.length];
                        }, delay);
                        delay += 30; // Faster sequential effect for inner bulbs
                    });
                }
            }
        }

        // Initialize all bulbs when the DOM is loaded
        function initializeAllBulbs() {
            const circleIds = ['circle-1', 'circle-2', 'circle-3', 'circle-4', 'circle-5', 'circle-6', 'circle-7'];
            const numberOfOuterBulbsPerCircle = 30; // Number of bulbs around the circumference for outer circles
            const outerBulbOffset = 5; // Pixels inwards from the border for outer bulbs (border is 2px)

            circleIds.forEach(id => {
                const circleElement = document.getElementById(id);
                if (circleElement) {
                    // Create bulbs for outer circles
                    createOutlineBulbs(circleElement, numberOfOuterBulbsPerCircle, 'outline-bulb', outerBulbOffset);
                }
            });

            // Initialize bulbs for the inner halo container
            const innerHaloContainer = document.getElementById('inner-halo-container');
            if (innerHaloContainer) {
                const numberOfInnerBulbs = 20; // Fewer, denser bulbs for inner halo
                // This offset is from the *edge of the inner-halo-container*, which itself is inset-0 from its parent.
                const innerBulbOffset = 5; // Increased offset to create more space
                createOutlineBulbs(innerHaloContainer, numberOfInnerBulbs, 'inner-halo-bulb', innerBulbOffset);
            }

            animateBulbs(); // Initial call to light up bulbs immediately
        }

        // Ensure bulbs are created and animated after the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            initializeAllBulbs();
            // Start the animation loop
            setInterval(animateBulbs, 1500); // Change pattern every 1.5 seconds
        });
        // Removed: window.addEventListener('resize', initializeAllBulbs); since responsiveness is removed.
    </script>

</body>
</html>
